\chapter{Data structures} \label{data-structures}

\section{Stack}
A stack (\texttt{std::stack}) is a sequencial data structure, where the most recently inserted element is the first to be removed (much like a stack of books, which we only interact with through the top of the stack).\par
We consider a stack $L$ has its top on the left side, and elements \emph{before} $u$ are closer to the top of the stack (or to the left of $u$). Thus, let $Before(v)$ be the set of nodes that are before $v$ in $L$, let $After(v)$ be the set of nodes that are after $v$ in $L$.

\section{Unordered set}
An unordered set (\texttt{std::unordered\_set}) is an associative type of container from the C++ Standard Library (STL). It stores a set of unique objects which are organized into buckets according to their hash values and are not sorted in any particular order. It is implemented as an hash table, allowing amortized constant-time complexity in search, insertion and removal of elements.

\section{Unordered map}
The unordered map data structure (\texttt{std::unordered\_map}) is also an associative container from the STL, used to store key-value pairs (with unique keys). It is implemented as an hash table (where the hash is calculated from the key), providing amortized constant-time complexity for search, insertion and removal operations.

\section{List}
A list is a sequential data structure which links an element to the element coming after it. The STL implementation (\texttt{std::list}) is a doubly-linked list, meaning each element keeps a link to the previous and following elements, so it allows forward- and backward-iteration, as well as constant-time insertion and deletion operations anywhere in the list, meaning it can be easily expanded and reduced.

\section{Vector}
A vector (\texttt{std::vector}) is a sequential data structure that uses a dynamically allocated array to store its elements. Vectors can allocate extra memory for future expansion, consuming more memory than C-arrays but having a much more simple interface. Since elements are sequentially stored in memory, they can be randomly accessed in constant time. Vectors can be reduced in constant time, and increased in amortized constant time, although it is mostly used in situations where the data structure is created once and not increased/reduced very often.

\section{Queue}
A queue (\texttt{std::queue}) is a FIFO data structure, where the first element to be added is processed first than all other elements.

\section{Shared queue}
A shared queue (\texttt{shared\_queue}) is a mere wrapper around a queue, which has a mutex to guarantee certain operations are performed atomically from threads' perspective by guaranteeing only a single thread can perform a certain action at each instant.

\section{Priority queue}
A priority queue (\texttt{std::priority\_queue}) is a data structure allowing insertion of elements associated with a \emph{priority}, and removing the element with the highest priority (if it is a maximum-priority queue). Its elements are non-increasingly ordered, meaning the first element is always the greatest. Therefore, it provides constant-time access to the greatest element, and logarithmic-time insertion and extraction.\par
A minimum-priority queue is similar to a maximum-priority queue, except elements are non-decreasingly ordered, so the first element is always the smallest.

\section{Graph}
We have already presented a theoretical definition of a graph, so now we will only mention our implementations, \texttt{DUGraph} and \texttt{DWGraph}.\par
Both structures represent a graph as an adjacency list, where we map each node to a set/map containing all adjacent nodes/edges. The only difference between \texttt{DUGraph} and \texttt{DWGraph} is that \texttt{DUGraph} stores the set of adjacent nodes for each node, while \texttt{DWGraph} stores for each node $u$ a map of pairs (node $v$, weight $c$), meaning there is an edge from $u$ to $v$ and the cost of going from $u$ to $v$ is $w(u,v)=c$.\par
We additionally keep some other structures, such as a list of all nodes so we can return a constant reference to the list of all nodes in constant time, as well as a mapping from each node to their precedessors, so we can more rapidly delete edges to any node $v$.

\section{Vertical stripes}
The \hyperref[algorithm-vstripes]{vertical stripes algorithm} is more of a data structure than an algorithm. Please check section \ref{algorithm-vstripes} for more details on this data structure/algorithm.