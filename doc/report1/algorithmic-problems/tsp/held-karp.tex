\subsection{Held-Karp algorithm} \label{algorithm-tsp-heldkarp}
The Held-Karp algorithm is a dynamic programming approach to problems similar to the \acrlong*{TSP}, proposed in 1962 independently by Richard Bellman \cite{bellman62} and by Michael Held and Richard Karp \cite{held-karp62}. The main idea is that the current state can be uniquely described by the city $v$ we are at, and the set $S$ of cities we have already visited (except for $s$, which will be the last city to be visited), and for each state we know the minimum cost $D(S,v)$ of reaching $v$ after having visited all cities in $S$. The algorithm then relies on a trivial recurrent formula to express the links between states, where the solution is $D(V, s)$:
\begin{algorithm}[H]
    \caption{Held-Karp algorithm}
    \label{alg:held-karp}
    \begin{algorithmic}[1]
        \For {$S \in \mathscr{P}(V),\,v \in V$} {$D(S,v)=\infty$}
        \EndFor
        \Function{HK}{$S=0$, $v=s$}
            \If {$D(S,v) \neq \infty$} \Return $D(S,v)$
            \EndIf
            \If {$S = \{v\}$} \Return {$D(S,v) \gets w(0, s, v)$} \Comment{$D(\{v\}, v)=w(\emptyset, s, v)$}
            \EndIf
            \For {$u \in S$}
                \State {$D(S,v) \gets \min\{D(S,v), \Call{HK}{S\backslash \{u\},u})$} \Comment{$D(S, v)=\min_{u \in S}\{D(S\backslash \{v\}, u) + w(S\backslash\{v\},u,v)\}$}
            \EndFor
            \State \Return {$D(S,v)$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}
As we will see, this algorithm has exponential complexity so it is only addequate for very small values of $|V|$, so set $S$ is usually implemented as a bitmask subset of $V$.
\subsubsection{Proof of correctness}
We will rather present an argument as to why these recurrencies are valid. A state can either be:
\begin{itemize}
    \item Of the form $(\{v\}, v)$. In this case, the only cost is to go from $s$ to $v$ with set $\emptyset$.
    \item Not of the form $(\{v\}, v)$. In this case, $v$ is not the only visited city so far, meaning this path has already passed through one of the cities $u \in S$. Therefore, we grab all solutions that go to $u \in S$ and evaluate which one yields the least cost.
\end{itemize}
\subsubsection{Complexity analysis}
There are $2^{|V|}$ subsets of $V$, and $|V|$ possibilities for $v$, meaning there are at most $|V| \cdot 2^{|V|}$ states. Some of these states are not valid or unreachable, but they don't ammount to a value that effectively reduces the time and memory complexities.\par
To find the value of a state $(S,v)$, we will iterate over $|S|$ other states. Since $|S|$ is at most $|V|$, we have a total time complexity of $\Theta (|V|^2 \cdot 2^{|V|})$. The memory complexity for this algorithm is $\Theta (|V| \cdot 2^{|V|})$, since we need to store the result for each state.\par
States of the forms $(S, v)\colon v \not \in S$ are not valid; these ammount to approximately half the states, so we can claim we have approximately $|V|\cdot 2^{|V|-1}$ valid states, and we will have to perform around $|V|^2\cdot 2^{|V|-1}$ operations.\par
\subsubsection{Remarks}
We will have to perform approximately $|V|^2\cdot 2^{|V|-1}$ operations. Using the rule-of-thumb that a computer can perform $10^8$ serial operations per second, and assuming as maximum van capacity the legal limit for european driving license category D1 (light buses with a maximum of 16 seats, not including driver)\cite{dir-2006-126-ec}, we can execute this algorithm in about $\SI{0.08}{s}$, which is acceptable if this algorithm is run only a few times.
