\subsection{Floyd-Warshall algorithm} \label{algorithm-shortestpath-floydwarshall}
The Floyd-Warshall's algorithm also knows as Floyd's algorithm was published in 1962 is a generalization of Warshall's algorithm 
(which only tested the existence of a path between two vertices) and corresponds to a dynamic programming method 
that finds the shortest path between each pair of vertices in a graph (whose edges' weights may be not only positive but also negative).\par
Assuming $dist(i, j)^{(k)}$ as the distance between $i$ and $j$ that resorts to the vertices $v_{1}$, $v_{2}$, ... $v_{k}$ to create that path
and that $W(i,j)$ is the weight function that returns the weight of the edge that connects the two vertices $i$ and $j$,
this algorithm follows the following recurrence:

\begin{equation}
    dist[i,j]^{(k)}=\begin{cases}
      W(i,j), & \text{if $k=0$}\\
      min(dist[i,j]^{(k-1)}, dist[i,k]^{(k-1)} + dist[k,j]^{(k-1)}), & \text{if $k>=1$}
    \end{cases}
\end{equation}

The base case corresponds to $k=0$ where $dist(i, j)^{(0)}$ is the value of the edge (if it exists) that connects those two vertices.
Otherwise, the length of the shortest path between vertices $i$ and $j$ is either the length of the path without considering the vertex
labeled as $k$ or the sum of the length of two paths: one from $i$ to $k$ and the other from $k$ to $j$.

\begin{algorithm}[ht]
    \caption{Floyd-Warshall algorithm}
    \label{alg:floyd-warshall}
    \begin{minipage}[t]{0.49\linewidth}
        (a) Mathematical version
        \begin{algorithmic}[1]
            \Function{FloydWarshall}{$G(V,E), W$}
                    \State $dist^{(0)} \gets $ new $ dist[V, V] = \infty$
                    \For{$each\ edge\ E(i,j)$}
                        \State $dist[i,j]^{(0)} \gets W(i,j)$
                    \EndFor
                    \For{$each\ vertex\ i$}
                        \State $dist[i,i]^{(0)} \gets 0$
                    \EndFor
                \For {$0 < k < V$}
                    \State $dist^{(k)} \gets $ new $ dist[V, V]$
                    \For {$0 < i < V$}
                        \For {$0 < j < V$}
                            \State $dist[i,j]^{(k)} \gets min( dist[i,j]^{(k-1)},$
                            $dist[i,k]^{(k-1)} + dist[k,j]^{(k-1)} )$
                        \EndFor
                    \EndFor
                \EndFor
                \State \Return{$dist^{(n)}$}
            \EndFunction
        \end{algorithmic}
    \end{minipage}
    \begin{minipage}[t]{0.49\linewidth}
        (b) Programmatic version
        \begin{algorithmic}[1]
            \Function{FloydWarshall}{$G(V,E), W$}
                \For {$i = 1\ to\ V$}
                    \For {$j = 1\ to\ V$}
                        \State $dist[0][i][j] = \inf$
                        \If{$(i,j) \in E$}
                            \State $dist[0][i][j] = W(i,j)$
                        \EndIf
                    \EndFor
                \EndFor
                \For {$k = 1 < V$}
                    \State $dist^{(k)} \gets $ new $ dist[n, n]$
                    \For {$i = 1\ to\ V$}
                        \For {$j = 1\ to\ V$}
                            \State $dist[k,i,j] = min(dist[k-1,i,j],$
                            $dist[k-1,i,k] + dist[k-1,k,j])$
                        \EndFor
                    \EndFor
                \EndFor
                \State \Return{$dist[k]$}
            \EndFunction
        \end{algorithmic}
    \end{minipage}
\end{algorithm}

\subsubsection{Complexity analysis}
By comparing every path of the graph between each pair of vertices, the Floyd-Warshall algorithm detains a time complexity in the order of $\Theta(|V|^3)$ due not only to the three nested $for$ loops but also to the $O(1)$ run time of line 11.\par
When it comes to memory expenditure, by creating k matrices, one for each iteration of the k for loop, it takes up $\Theta(|V|^3)$ which can be reduced to $\Theta(|V|^2)$ if instead of creating a new matrix, the existing one is updated.

\subsubsection{Remarks}
Even though the Floyd-Warshall's algorithm functions correctly with negative weight edges, being able also to detect negative cycles, these features will most likely not be of much use, due to the nature of the problem:
the time it takes to get from one location to another must be a value equal to (in the case of the ``current position" being equal to the ``final position") or greater than zero.