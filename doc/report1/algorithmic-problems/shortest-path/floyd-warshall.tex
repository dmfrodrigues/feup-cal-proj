\subsection{Floyd-Warshall algorithm} \label{algorithm-shortestpath-floydwarshall}
The Floyd-Warshall algorithm was published in 1962 as a generalization of Warshall's algorithm for the \hyperref[def:desc]{transitive closure} \cite[p.~346]{floyd-alg}. It is a \gls{recursive} algorithm that applies a \gls{dynamic programming} approach 
to find the shortest path between each pair of vertices in a graph, even if edges have negative weights.\par
Consider each vertex in $V$ is identified by a unique integer $1 \leq i \leq |V|$.
Let $dist(i, j)^{(k)}$ be the cost of the shortest path from $i$ to $j$ using vertices $1, 2, ..., k$.
This algorithm follows the recurrence adapted from \cite{intro-alg}:

\begin{equation}
    dist(i,j)^{(k)}=\begin{dcases}
        \infty                                                         &: k=0 \wedge (i,j) \not \in E \\
        w(i,j)                                                         &: k=0 \wedge (i,j) \in E\\
        \min\{dist(i,j)^{(k-1)}, dist(i,k)^{(k-1)} + dist(k,j)^{(k-1)}\}, &: k \geq 1
    \end{dcases}
\end{equation}

The base case corresponds to $k=0$ where $dist(i, j)^{(0)}$ is the value of the edge if it exists (or $\infty$ otherwise) that connects those two vertices.
Otherwise, the length of the shortest path from $i$ to $j$ is the least of the length of the path without considering the vertex labeled as $k$,
or the length of the shortest path from $i$ to $j$ via $k$ (i.e., from $i$ to $k$ and from $k$ to $j$).\par

\begin{algorithm}[ht]
    \caption{Floyd-Warshall algorithm}
    \label{alg:floyd-warshall}
    \begin{algorithmic}[1]
        \Function{FloydWarshall}{$G(V,E, w)$}
            \For {$i, j \in V$} \Comment{Initializations}
                \State {$dist(i,j)^{(0)} \gets \infty$}
                \For {$k \in V$} {$prev(i,j)^{(k)} \gets \text{NULL}$}
                \EndFor
            \EndFor
            \For{$i \in V$} $dist(i,i)^{(0)} \gets 0$
            \EndFor
            \For{$(i,j) \in E$} \Comment{Add edges}
                \State $dist(i,j)^{(0)} \gets w(i,j)$
                \State $prev(i,j)^{(j)} \gets i$
            \EndFor
            \For {$1 \leq k \leq |V|$} \Comment{Main cycle}
                \For {$1 \leq i,j \leq |V|$}
                    \State {$c' \gets dist(i,k)^{(k-1)} + dist(k,j)^{(k-1)}$}
                    \If {$c' < dist(i,j)^{(k)}$}
                        \State {$dist(i,j)^{(k)} \gets c'$}
                        \State {$prev(i,j)^{(k)} \gets prev(k,j)^{(k)}$}
                    \EndIf
                \EndFor
            \EndFor
            \State \Return{$dist^{(|V|)}$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\subsubsection{Complexity analysis}
By comparing every path of the graph between each pair of vertices, the Floyd-Warshall algorithm has a time complexity of $O(|V|^3)$ due not only to the three nested $for$ loops but also to the fact all elementary operations having $O(1)$ run time.\par
When it comes to memory, by creating $k$ matrices, one for each iteration of the outer-most \textbf{for} loop, it takes up $O(|V|^3)$. This can be reduced to $O(|V|^2)$ if, on processing $dist^{(k)}$, we only hold the previous matrix $dist^{(k-1)}$, or we can even reduce it in half if we always perform updates over the same matrix, thus making unnecessary to hold the previous matrix.

\subsubsection{Remarks}
The added flexibility of working with negative-weight edges is not particularly useful in our case, since the time it takes to travel between two places must be equal to (should the two positions be the same) or greater than zero. Besides, Dijkstra's algorithm can produce the same result in time $O(|V|^2 \log {|V|})$.