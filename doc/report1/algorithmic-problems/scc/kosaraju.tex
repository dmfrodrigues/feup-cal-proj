\subsection{Kosaraju's algorithm} \label{algorithm-scc-kosaraju}
Kosaraju's algorithm was first sugested by Sambasiva Rao Kosaraju in 1978, but only published in 1981 by Micha Sharir \cite{sharir81}, independently. It makes use of the following lemma:
\begin{lemma} \label{lem:kosaraju1}
    Let $C$ and $C'$ be distinct strongly connected components in directed graph $G(V,E)$, let $u,v \in C$, let $u',v' \in C'$, and assume
    \begin{equation}
        \label{eq:utou_} u \leadsto u'
    \end{equation}
    Then it is impossible that
    \begin{equation}
        \label{eq:v_tov} v' \leadsto v
    \end{equation}
\end{lemma}
\begin{proof} From $u, v \in C$ and that $C$ is a SSC, we can assume
    \begin{equation}
        \label{eq:vtou} v \leadsto u
    \end{equation}
    From $u', v' \in C'$ and that $C'$ is a SSC, we can assume
    \begin{equation}
        \label{eq:u_tov_} u' \leadsto v'
    \end{equation}
    By \eqref{eq:utou_} and \eqref{eq:u_tov_}, $u \leadsto u' \leadsto v'$.\par
    Assume the absurd \eqref{eq:v_tov}. Then, by \eqref{eq:v_tov} and \eqref{eq:vtou}, $v' \leadsto v \leadsto u$. Thus, $u$ and $v'$ are reachable from each other, thereby contradicting the assumption that $C$ and $C'$ are distinct strongly connected components.
\end{proof}
\begin{center}
    \begin{algorithm}
        \caption{Kosaraju's algorithm}
        \label{alg-kosaraju}
        \begin{minipage}[t]{0.49\linewidth}
            (a) Programmatic version
            \begin{algorithmic}[1]
                \State{$V = \emptyset$}
                \State{$L = \Call{Stack}{ }$}
                \Function{DFS\_K}{$Adj$, $u$}
                    \If{$u \in V$} {\Return{}}
                    \EndIf
                    \For{$v : Adj[u]$} 
                    \State{\Call{DFS\_K}{$Adj$, $v$}}
                    \EndFor
                    \State{$L.\Call{Push}{u}$}
                \EndFunction

                \State{$SCC[|Adj|] = \text{NULL}$}

                \Function{Assign}{$Adj$, $u$, $root$}
                    \If{$SCC[u] \neq \text{NULL}$} {\Return{}}
                    \EndIf
                    \State{$SCC[u] = root$}
                    \For{$v : Adj[u]]$}
                        \State{\Call{Assign}{$Adj$, $v$, $root$}}
                    \EndFor
                \EndFunction

                \Function{Kosaraju}{$Adj$}
                \For{$u = 1:|Adj|$} {\Call{DFS\_K}{$Adj$, $u$}}
                \EndFor
                \State {$Adj. \Call{Transpose}{ }$}
                \While{$!L.\Call{Empty}{ }$}
                    \State{$u = L. \Call{Pop}{ }$}
                    \State \Call{Assign}{$Adj$, $u$, $u$}
                \EndWhile
                \State \Return{$SCC$}
                \EndFunction
            \end{algorithmic}
        \end{minipage}
    \end{algorithm}
\end{center}
\subsection{Proof of correctness}

\subsection{Complexity analysis}
Analysing each part of the algorithm, both DFS\_K and Assign functions yeald time complexity $O(|V|+|E|)$ since they are fundamentally DFS's \ref{algorithm-reachability-dfs}. The \text{Transpose} operation also yields $O(|V|+|E|)$.
Memory-wise, the visited nodes V, the stack L and the resulting SCC's are all $O(|V|)$. On another note, the \text{Transpose} operation is also $O(|V|)$ because it is an in-place operation.


% DFS_K O(|V|+|E|)
% Transpose O(|V| + |E|)
% Corridas de Assign O(|V|+|E|) 
% DFS_K e Assign sao fundamentalmente DFS's portanto tem O(|V|+ |E|) (ref à secçao dfs)

% V |V| 
% L |V| (eventualmente todos os nodos vao estar na stack)
% SCC |V| 
% Transpose tem memoria O(1) in-place