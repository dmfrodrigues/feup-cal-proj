\subsection{Variant of Kosaraju's algorithm} \label{algorithm-scc-kosaraju-v}
We can use a simplified version of Kosaraju's algorithm if we want to find $SCC(s)$, by applying theorems \ref{theor:pred-desc} and \ref{teor:scc}:
\begin{equation*}
    SCC_G(s) = Desc_G(s) \cap Pred_G(s) = Desc_G(s) \cap Desc_{G^T}(s) 
\end{equation*}
The descendants of a node can be trivially found using \acrshort{DFS}. The time complexity of operations \textsc{DFS} and \textsc{Transpose} is $O(|E|+|V|)$. After obtaining $P$, we can convert it to an array of booleans in $O(|V|)$, and then query about the existence of an element in $P$ in $O(1)$. Iterating over an element of $D$ takes $O(1)$, and inserting in $SCC$ can be $O(1)$ if it is a list or an array of booleans, or $O(1)$ amortized if it is an hash table, so the \textbf{for} cycle has complexity $O(|V|)$. Thus, the total time complexity of this algorithm is $O(|E|+|V|)$.\par
In terms of memory, \textsc{DFS} takes $O(|V|)$, \textsc{Transpose} takes $O(1)$ and sets $P$, $D$ and $SCC$ take $O(|V|)$, so the total memory complexity of this algorithm is $O(|V|)$.
