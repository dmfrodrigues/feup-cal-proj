\subsection{Tarjan's algorithm} \label{algorithm-scc-tarjan}
Similar to Kosaraju's algorithm, Tarjan's algorithm, proposed by Robert Tarjan in 1972 \cite{tarjan72}, uses the ordered DFS of all nodes, starting on a random node, to find all \acrshortpl*{SCC}. However, it makes use of memory to bookkeep each visited node's index and lowlink (corresponds to the smallest index of any node known to be reachable from its DFS subtree). 
\begin{center}
    \begin{algorithm}[H]
        \caption{Tarjan's algorithm}
        \label{alg-tarjan}
        \begin{minipage}[t]{0.40\linewidth}
            (a) Main algorithm
            \begin{algorithmic}[1]
                \Function{Tarjan}{$G(V,E)$}
                    \For{$u \in V$}
                        % Ha forma melhor de fazer esta inicializa√ßao ? (inline quando e definido)
                        \State{$ids[u] \gets 0$}
                        \State{$SCC[u] \gets 0$}
                    \EndFor
                    \For{$u \in V$}
                        \If{$ids[u] = 0$} 
                            \Call{DFS\_T}{$G$, $u$}
                        \EndIf
                    \EndFor
                    \State \Return{$SCC$}
                \EndFunction
            \end{algorithmic}
        \end{minipage}
        \begin{minipage}[t]{0.58\textwidth}
            (b) Helper functions
            \begin{algorithmic}[1]
                \State{$id \gets 0, ~L \gets \Call{Stack}{ }$}

                \Function{DFS\_T}{$G$, $u$}
                    \State{$L.\Call{Push}{u}$}
                    \State{$ids[u] \gets ++id$} % Pode se ++?
                    \State{$SCC[u] \gets id$}

                    \For{$v \in \Call{Adj}{G, u}$}
                        \If{$ids[v] = 0$} {\Call{DFS\_T}{$G$, $v$}}
                        \EndIf
                        \If{$v \in L$} {$SCC[v] = \min \{SCC[u], SCC[v]\}$}
                        \EndIf
                    \EndFor

                    \If{$ids[u] = SCC[u]$}
                        \While{$(node = L.\Call{Pop}{ }) \neq u$} % Spaguetti af ??
                            \State{$SCC[node] \gets ids[node]$}
                        \EndWhile
                    \EndIf
                \EndFunction
            \end{algorithmic}
        \end{minipage}
    \end{algorithm}
\end{center}
\subsubsection{Proof of correctness}
!DO 
\subsubsection{Complexity analysis}
Simlar to Kosaraju's algorithm, Tarjan's yields time complexity $O(|V|+|E|)$ in the DFS\_T function since it iterates once over all nodes. However, this can only be achieved if the test $u \in L$ is done in constant time $O(1)$, by, for example, storing this information in an array of flags $onStack[|V|]$.
The drawback to this method over its predecessor is the space complexity, for which it yields $O(|V|)$, since in the worst case it stores a stack and an array of all node indexes with complexity $O(|V|)$, along with the fields $index$ and $onStack$ for each node. 