\documentclass{report}[a4paper]
% Decent underlines
\usepackage[normalem]{ulem}
% Hyperreferences
\usepackage{hyperref}
% Margins
\usepackage[top=35mm,bottom=35mm,left=25mm,right=25mm]{geometry}
% Graphics and images
\usepackage{graphicx} \graphicspath{{./images/}}
\usepackage{subcaption}
\usepackage{float}
% Encodings (to render letters with diacritics and special characters)
\usepackage[utf8]{inputenc}
% Language
\usepackage[english]{babel}
% Source code
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
% Tables with bold rows
\usepackage{tabularx}
\newcommand\setrow[1]{\gdef\rowmac{#1}#1\ignorespaces}
\newcommand\clearrow{\global\let\rowmac\relax}
\clearrow
\usepackage{multirow}
% Math stuff
\usepackage[mathscr]{euscript}
\usepackage{amsmath,amssymb}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{bm}
\usepackage{xcolor}
\newcommand{\expnumber}[2]{{#1}\mathrm{e}{#2}} % scientific notation
% Definitions, theorems, remarks,...
\usepackage{amsthm}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\renewcommand\qedsymbol{$\blacksquare$}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
% Contents title
\addto\captionsenglish{\renewcommand*\contentsname{Table of contents}}
% Headers and footers
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhf{}
\lhead{\fancyplain{}{PortoCityTransfers — Delivery I (CAL 2019/20)}}
\rhead{\fancyplain{}{Group T6G05}}
\lfoot{\fancyplain{}{\leftmark}}
\rfoot{\thepage}
%
\newcommand{\email}[1]{
{\texttt{\href{mailto:#1}{#1}} }
}
% Metadata
\title{\Huge PortoCityTransfers \\ \Large Delivery I \\ \vspace*{4pt} \large CAL 2019/20}
\author{
Group T6G05 \vspace{0.5em} \\
\begin{tabular}{r l}
	\email{up201806429@fe.up.pt} & Diogo Miguel Ferreira Rodrigues        \\
	\email{up201806613@fe.up.pt} & João António Cardoso Vieira e Basto de Sousa \\
	\email{up201806330@fe.up.pt} & Rafael Soares Ribeiro \\
\end{tabular}
}
\date{10/04/2020}
% Document
\begin{document}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents
\listofalgorithms
\chapter{Introduction}
This preliminary report details the project to be designed and implemented.
This project fundamentally consists of an application for managing a train station shuttle service based in a single train station, serving clients in the area inside and surrounding a big city.
\chapter{Theme description}
The company \emph{PortoCityTransfers} provides shttle services beetween Campanhã railway station (Porto, Portugal) and hotels/other places in the Porto region (Porto, Matosinhos, Maia, Vila Nova de Gaia). For that end, it owns a certain number of vans, which can transport a given number of passangers each. Service reservation must be made via Internet, where clients can indicate their estimated time of arrival and final destination. Given a set of service requests to satisfy in a given day, and their respective destinations, the company must group passangers and plan routes for that day, having in mind passangers should wait for a period as short as possible.\par
This project will design and implement a computer system that will allow \emph{PortoCityTransfers} to plan its routes. The following iterations should be considered for project development:
\begin{enumerate}
    \item The company owns a single van.
    \item The company owns several vans, where multiple travels are simultaneously possible for different vans.
    \item Passangers without reservation must be accounted for, as well as passangers that wish to travel from their homes to the train station.
\end{enumerate}
\chapter{Graph notions}
This short chapter presents some basic notions and definitions on graphs, which ought to be useful in the following chapters.
\section{Definitions}
\begin{definition}[Directed weighted graph]
    A directed weighted graph $G$ is a triple $(V, E, w)$, where:
    \begin{itemize}
        \item $V$ is the finite set of \textbf{nodes}.
        \item $E \subseteq V^2$ is the set of \textbf{edges}, where each edge is a pair $(u,v)$ describing an origin and destination.
        \item $w: E \rightarrow \mathbb{R}^+$ is the \textbf{cost function} that maps each edge to a traversal cost.
    \end{itemize}
\end{definition}
\begin{definition}[Path]
    A path $p$ of length $k$ in a graph $G(V,E)$ is a sequence of nodes $\langle p_0,p_1,p_2,...,p_k\rangle$ such that
    \begin{alignat*}{5}
        \text{(All nodes belong to the graph)}       ~~&\forall~0 \leq &&i   &&<    k,&&~p_i \in V \\
        \text{(Node is reachable from previous node)}~~&\forall~0 \leq &&i   &&<    k,&&~(p_i, p_{i+1}) \in E \\
        \text{(No repeated nodes)}                   ~~&\forall~0 \leq &&i,j &&\leq k,&&~i\neq j \implies p_i \neq p_j \\
        \text{(No repeated edges)}                   ~~&\forall~0 \leq &&i,j &&<    k,&&~i\neq j \implies (p_i,p_{i+1}) \neq (p_j, p_{j+1})
    \end{alignat*}
\end{definition}
\begin{definition}[Set of all paths]
    $P(G)$ is the set of all paths in graph $G(V,E)$.
\end{definition}
\begin{definition}[Weight of a path]
    The weight of a path $p$ of length $k$ in graph $G(V,E,w)$ is
    \begin{equation*}
        W(p) = \sum_{i=0}^{k-1}{w(p_i, p_{i+1})}
    \end{equation*}
\end{definition}
\begin{definition}[Adjacency set]
    The adjacency set of $u \in V$ in $G(V,E)$ is the set of nodes directly reachable from $u$:
    \begin{equation*}
        Adj(G, u) = \{(u, v) \in E\} = E \cap (\{v\}\times V)
    \end{equation*}
\end{definition}
\begin{definition}[Strongly connected component]
    A strongly connected component $SCC$ is a subset of the nodes $V$ in a graph $G(V,E)$ where there is a path between any two nodes $u, v \in SSC$, and there is no other node $x \not \in SSC$ that can reach and be reached by all nodes $u \in SSC$.
\end{definition}
\chapter{Problem formalization}
This chapter is dedicated to the hardest, algorithmic problems related to this project. Therefore, we will only go into detail about aspects that algorithmically influence the project.
\section{Input}
There are two main inputs to this problem: a description of the map of the area the company serves (section \ref{input-map}); the list of requested services for a given day (section \ref{input-services}).
\subsection{Map} \label{input-map}
We will abstract the area \emph{PortoCityTransfers} serves into a graph $G=(V,E, w)$, where:
\begin{itemize}
    \item Nodes $V$ represent positions on Earth.
    \item Edges $E$ represent roads traversable by automobiles.
    \item Weight function $w$ is the time it takes to cross an edge. Considering an estimated average distance between successive nodes of about $5 m$, and that travelling at a maximum speed of $120 km/h$ a vehicle would take $0.15 s$ to cross it, cost will be expressed in integer milliseconds which is deemed a unit with more than enough precision, while still being relatively easy to manage as well as fitting in a 32-bit unsigned integer.
\end{itemize}
We thus have as input data the directed weighted graph $G=(V,E,w)$.
\subsection{Services} \label{input-services}
Services requested to the company are either from or to the train station. Thus, for each request, we need to know the origin, destination and the time the person can be picked up.
We thus have as input data the sequence $r$ of clients $\langle c[0], c[1], ..., c[k-1] \rangle$ where each client $c_i=(u, v, t)$ can be picked at $u$ starting in time $t$, and must be dropped at $v$.
\section{Output}
For each van, a sequence $l=\langle l[0], l[1], ..., l_k \rangle$ of all routes where $l[i]=r=\langle r[0], r[1],..., r[k']\rangle$ is a route, which is a sequence of space-time coordinates $r[i]=(v, t)$, meaning the van must be at node $v$ at time $t$. REWRITE
\section{Restrictions}
\begin{enumerate}
    \item Each route starts and ends in the train station; $\forall r,\,r[0]=r[k']=$ node of the train station.
    \item Each route must be feasible, meaning for each consecutive space-time pair the van has enough time to travel from one location to the next one. Let $dist(u, v)$ be the \emph{distance} or cost between the two nodes (this cost is, in reality, the time it takes to go from $u$ to $v$);
    \begin{equation*}
        \forall i \in \mathbb{N}, 0 \leq i < k' \implies dist(r[i].v, r[i+1].v) \leq r[i+1].t-r[i].t
    \end{equation*}
    \item For each van with a list of routes $l$, a van can only perform the following order after the previous order is completed:
    \begin{equation*}
        \forall i \in \mathbb{N}, 0 \leq i < k \implies l[i][\text{end}].t \leq l[i+1][0].t
    \end{equation*}
    \item All clients must be picked up from their origins and delivered to their destinations.
    \item REWRITE
\end{enumerate}
\section{Objective function}
\section{Problem decomposition}
For each iteration, we will decompose larger problems into successively smaller, well-known (and preferably classical) problems.
\subsection{Iteration I}
On iteration I, the company owns one van REWRITE
\chapter{Algorithmic problems}
\section{Reachability problem}
\begin{itemize}
    \item \textbf{Summary:} Given a directed unweighted graph, find all nodes reachable from one node.
    \item \textbf{Input:} Graph $G=(V,E)$ and origin node $s \in V$.
    \item \textbf{Output:} Set $R=\{d \in V \mid \exists~p \in P(G)\colon p_0 = s \wedge p_k = d\}$.
\end{itemize}
\subsection{Depth-first search}
Depth-first search is a very elementary graph traversal, which explores nodes in depth before backtracking.
\vspace{-1em}
\begin{center}
    \begin{algorithm}[ht]
        \caption{Depth-first search}
        \label{alg-dfs}
        \begin{minipage}[t]{0.49\linewidth}
            (a) Mathematical version
            \begin{algorithmic}[1]
                \State $R \gets \emptyset$
                \Function{DFS}{$G(V,E)$, $u$}
                    \If {$u \in R$} \Return {$ $}
                    \EndIf 
                    \State {$R \gets R \cap \{u\}$}
                    \For {$v \in \Call{Adj}{G, u}$}
                        \State {$\Call{DFS}{G, v}$}
                    \EndFor
                    \State \Return $R$
                \EndFunction
            \end{algorithmic}
        \end{minipage}
        \begin{minipage}[t]{0.49\linewidth}
            (b) Programmatic version
            \begin{algorithmic}[1]
                \State $R[|Adj|] = \text{FALSE}$
                \Function{DFS}{$Adj$, $u$}
                    \If {$R[u]$} \Return {$ $}
                    \EndIf 
                    \State {$R[u] = \text{TRUE}$}
                    \For {$v : Adj[u]$}
                        \State {$\Call{DFS}{Adj, v}$}
                    \EndFor
                    \State \Return $R$
                \EndFunction
            \end{algorithmic}
        \end{minipage}
    \end{algorithm}
\end{center}
\vspace{-2em}
\subsubsection{Proof of correctness}
\begin{lemma} \label{lem:dfs}
    If $u$ is reachable from $s$ and $v$ is adjacent to $u$, then $v$ is reachable from $s$.
\end{lemma}
\begin{proof}
    If $u$ is reachable from $s$, then $\exists p \in P(G) \colon p_0 = s \wedge p_k = u$. Let that path be $p^u$. If $v$ is adjacent to $u$ then $(u,v) \in E$. We can thus add $v$ to the end of path $p^u$, which will either be a valid path, or an invalid path which means $v$ was already in $p^u$ in position $j$, implying $p^u[0:j]$ is a path from $s$ to $v$.
\end{proof}
\begin{theorem}
    Depth-first search algorithm starting in $s$ finds all nodes reachable from $s$.
\end{theorem}
\begin{proof} \textbf{Base case:} $u=s$; $s$ is trivially reachable from itself. \\
\textbf{Inductive step:} suppose \textsc{DFS} is always called for a node $u$ reachable from $s$. From lemma \ref{lem:dfs} we know all nodes adjacent to $u$ are reachable from $s$. Since \textsc{DFS} is only called for the nodes adjacent to $u$ the inductive implication holds.\par
We have thus proven the theorem correct by induction.
\end{proof}
\subsubsection{Complexity analysis}
Each node is explored once, and for each node all its adjacent nodes are explored via all edges. All elementary operations are $O(1)$, making this algorithm run in time $O(|E|+|V|)$.\par
In terms of memory, each call takes $O(1)$ memory and the call chain can be as long as many nodes are there. This means this algorithm uses $O(|V|)$ memory.
\section{Shortest path problem}
\begin{itemize}
    \item \textbf{Summary:} Given a weighted directed graph, find the path with least cost from one node to another.
    \item \textbf{Input:} Graph $G=(V,E,w)$ and origin/destination nodes $s, d \in V$.
    \item \textbf{Output:} Path $p$ in $G$.
    \item \textbf{Objective function:} $W(p)~\min$.
\end{itemize}
\subsection{Dijkstra's algorithm}
Dijkstra's algorithm is one of the most famous graph algorithms, and the most popular shortert path-finding algorithm between nodes. It was first published in 1959 by Dutch computer scientist Edsger Dijkstra \cite{dijkstra}.\par
This algorithm finds the distance between a node $s$ and every other node $d$ reachable from $s$ (thus solving the shortest path problem in the meantime). The fundamental idea is that, at each moment, we hold a set $Q$ of unprocessed nodes, and we know for all nodes the values of functions distance $dist$ and previous node $prev$ (temporary if the node is in $Q$, final otherwise). We then process the node $u \in Q$ with the least distance to $s$, which consists of iterating over all nodes adjacent to $u$, calculate their potential new distance to $s$ passing through $u$ ($c'=c+w(u,v)$), and if the new distance is smaller we update distance $dist(v)=c'$ and previous node $prev(v)=u$.
\begin{center}
    \begin{algorithm}[ht]
        \caption{Dijkstra's algorithm}
        \label{alg-dijkstra}
        \begin{minipage}[t]{0.49\linewidth}
            (a) Mathematical version
            \begin{algorithmic}[1]
                \Function{Dijkstra}{$G(V,E)$, $s$}
                    \State $Q \gets \emptyset$
                    \For {$v \in V$}
                        \State {$dist(v) \gets \infty$}
                        \State {$prev(v) \gets \text{NULL}$}
                        \State $Q \gets Q \cup \{v\}$
                    \EndFor
                    \State {$dist(s) \gets 0$}
                    \While {$|Q| > 0$}
                        \State $u \gets \text{element of } Q \text{ with least } dist(u)$
                        \State $Q \gets Q \backslash \{u\}$
                        \For {$v \in \Call{Adj}{G, u}$}
                            \State $c' \gets c + w(u, v)$
                            \If {$c' < dist(v)$}
                                \State $dist(v) \gets c'$
                                \State $prev(v) \gets u$
                            \EndIf
                        \EndFor
                    \EndWhile
                    \State \Return $dist$, $prev$
                \EndFunction
            \end{algorithmic}
        \end{minipage}
        \begin{minipage}[t]{0.49\linewidth}
            (b) Programmatic version
            \begin{algorithmic}[1]
                \Function{Dijkstra}{$Adj$, $s$}
                    \State $Q = \Call{Min\_Priority\_Queue}{ }$
                    \For {$v : V$}
                        \State {$dist[v] = \infty$}
                        \State {$prev[v] = \text{NULL}$}
                        \State {$Q.\Call{Insert\_With\_Key}{\infty, v}$}
                    \EndFor
                    \State $dist[s] = 0$
                    \State $Q.\Call{Decrease\_Key}{s, dist[s]}$
                    \While {$Q.\Call{Size}{ } > 0$}
                        \State $u = Q.\Call{Extract\_Min}{ }$
                        \For {$(v, w): Adj[u]$}
                            \State $c' = c + w$
                            \If {$c' < dist[v]$}
                                \State $dist[v] = c'$
                                \State $prev[v] = u$
                                \State $Q.\Call{Decrease\_Key}{v, dist[v]}$
                            \EndIf
                        \EndFor
                    \EndWhile
                    \State \Return {$dist$, $prev$}
                \EndFunction
            \end{algorithmic}
        \end{minipage}
    \end{algorithm}
\end{center}
For Dijkstra's algorithm we usually represent the graph as an adjacency list $Adj$ (admits iteration in $O(1)$ for each adjacent node). We also use a minimum priority queue for $Q$, where the key of $u$ is $dist(u)$ (fast extraction of element with smallest key and key decrease when processing adjacent nodes).
\subsubsection{Proof of correctness}
The full proof is rather long and is promptly available, thus we will only present a short argument for correctness. The full proof can be found, for instance, in \cite[p.~659]{intro-alg}
\begin{itemize}
    \item \textbf{Pre-conditions:} $G(V, E, w)$ is a graph. $s \in V$. $Q$ contains all nodes. $dist(s)=0$ and $prev(s)=\text{NULL}$
    \item \textbf{Post-conditions:} shortest path distance $dist(u)$ and previous node $prev(u)$ from $s$ to $\forall u \in V$ are final. Distance of unreachable nodes is $\infty$ and previous node in shortest path is invalid. Previous node for $s$ is also invalid.\par
    \item \textbf{Cycle invariant:} $\forall u \not \in Q$, $dist(u)$ is the weight of the shortest path from $s$ to $u$ and $prev(u)$ is the previous node in the shortest path from $s$ to $u$. $\forall u \in Q$, $dist(u)$ is the least distance from $s$ to $u$ going only through nodes not in $Q$.\par
    This holds for the next cycle run because the element $u$ we remove from $Q$ already has the least $dist(u)$ passing through nodes $u' \not \in Q$, and it can't pass through nodes $u' \in Q$ because there is no node with less $dist(u')$ that would allow to reduce $dist(u)$ even further.
    \item \textbf{Cycle variant:} $|Q|$, which is:
    \begin{itemize}
        \item Integer, given a size can only be integer.
        \item Strictly decreasing, given that one node is removed from $Q$ everytime the cycle runs.
        \item Positive, given it starts with value $|V|$ where $V$ has at least node $s$. The cycle breaks when $|Q| = 0$.
    \end{itemize}
\end{itemize}
\subsubsection{Complexity analysis}
The initial calls to \textsc{Insert\_With\_Key} are made in time $O(|V|)$, given all keys are $\infty$ and the heap property is always maitained. In the main cycle, all elementary operations are done in $O(1)$ except for $Q$ operations \textsc{Extract\_Min} and \textsc{Decrease\_Key}. Let their time complexities be $O(\text{T}_{em})$ and $O(\text{T}_{dk})$ respectively. \textsc{Extract\_Min} is run once for each of the $|V|$ nodes we remove from $Q$. For each node $u$ we iterate over $Adj[u]$, thus iterating once over each of the $|E|$ edges, potentially running \textsc{Decrease\_Key} for each edge. This yields the total time complexity $O(|E|\cdot \text{T}_{dk}+|V|\cdot \text{T}_{em})$. \par
Implementing $Q$ as a binary heap, we have $O(\text{T}_{dk})=O(\log |V|)$ and $O(\text{T}_{em})=O(\log |V|)$, thus yielding the total time complexity $O((|E|+|V|)\log |V|)$. This can be further improved with a Fibonacci heap, with $O(\text{T}_{dk})=O(1)$ and $O(\text{T}_{em})=O(\log |V|)$ (both amortized), thus yielding $O(|E| + |V|\log |V|)$.\par
The algorithm takes as much memory as the heaps, thus giving a memory complexity of $O(|V|)$.
\subsection{A* algorithm}
The A* shortest path algorithm is a very well known and widely used algorithm for fast path-finding. It was created by Peter Hart, Nils Nilsson and Bertram Raphael of Stanford Research Institute \cite{Astar}, as part of the Shakey project, with the aim of building a mobile robot that could plan its own actions.\par
This algorithm is an extension of the Dijkstra algorithm, using the heuristic function $\hat{h}(u)$ to estimate the distance from $u$ to $d$. In fact, for $\hat{h}(u) = 0$ we trivially obtain Dijkstra's algorithm, which confirms that it makes no assumptions about the context of the graph, and that the A* algorithm is an extension of it.
\begin{center}
    \begin{algorithm}[H]
        \caption[A* algorithm]{A* algorithm\\Added lines in green, changed expressions in orange, relative to Dijkstra's algorithm (Algorithm \ref{alg-dijkstra})}
        \label{alg-astar}
        \begin{minipage}[t]{0.49\linewidth}
            (a) Mathematical version
            \begin{algorithmic}[1]
                \Function{Astar}{$G(V,E)$, $s$, $\hat{h}$}
                    \State $Q \gets \emptyset$
                    \For {$v \in V$}
                        \State {$dist(v) \gets \infty$}
                        \State {$\textcolor{green}{\bm{hdist(v) \gets \infty}}$}
                        \State {$prev(v) \gets \text{NULL}$}
                        \State $Q \gets Q \cup \{v\}$
                    \EndFor
                    \State $dist(s) \gets 0$
                    \State $\textcolor{green}{\bm{hdist(s) \gets \hat{h}(s)}}$
                    \While {$|Q| > 0$}
                        \State $u \gets \text{element of } Q \text{ with least } \textcolor{orange}{\bm{hdist}}(u)$
                        \State $Q \gets Q \backslash \{u\}$
                        \For {$v \in \Call{Adj}{G, u}$}
                            \State $c' \gets c + w(u, v)$
                            \If {$c' < dist(v)$}
                                \State $dist(v) \gets c'$
                                \State $\textcolor{green}{\bm{hdist(v) \gets c'+\hat{h}(v)}}$
                                \State $prev(v) \gets u$
                            \EndIf
                        \EndFor
                    \EndWhile
                    \State \Return $dist$, $prev$
                \EndFunction
            \end{algorithmic}
        \end{minipage}
        \begin{minipage}[t]{0.49\linewidth}
            (b) Programmatic version
            \begin{algorithmic}[1]
                \Function{Astar}{$Adj$, $s$, $\hat{h}$}
                    \State $Q = \Call{Min\_Priority\_Queue}{ }$
                    \For {$v : V$}
                        \State {$dist[v] = \infty$}
                        \State {$\textcolor{green}{\bm{hdist[v] = \infty}}$}
                        \State {$prev[v] = \text{NULL}$}
                        \State {$Q.\Call{Insert\_With\_Key}{\infty, v}$}
                    \EndFor
                    \State $dist[s] = 0$
                    \State $\textcolor{green}{\bm{hdist[s] = \hat{h}(s)}}$
                    \State $Q.\Call{Decrease\_Key}{s, \textcolor{orange}{\bm{hdist}}[s]}$
                    \While {$Q.\Call{Size}{ } > 0$}
                        \State $u = Q.\Call{Extract\_Min}{ }$
                        \For {$(v, w): Adj[u]$}
                            \State $c' = c + w$
                            \If {$c' < dist[v]$}
                                \State $dist[v] = c'$
                                \State $\textcolor{green}{\bm{hdist[v] = c'+\hat{h}(v)}}$
                                \State $prev[v] = u$
                                \State $Q.\Call{Decrease\_Key}{v, \textcolor{orange}{\bm{hdist}}[v]}$
                            \EndIf
                        \EndFor
                    \EndWhile
                    \State \Return {$dist$, $prev$}
                \EndFunction
            \end{algorithmic}
        \end{minipage}
    \end{algorithm}
\end{center}
\subsubsection{Proof of correctness}
According to \cite{Astar}, if the heuristic $\hat{h}$ always returns a lower bound for the actual distance $h$ from $u$ to $d$ ($\forall u \in V, \hat{h}(v) \leq h(u)$), then the A* algorithm is guaranteed to find an optimal solution if it exists. This proof is fully presented in the original article so we will only present a brief argument. ARGUMENT\par
This means the A* algorithm is as effective as Dijkstra's path-finding algorithm as long as $\hat{h}$ provides a lower bound for $h$.
\subsubsection{Complexity analysis}
The poorest choice of heuristic that optimally solves the problem $\hat{h}(u)=0$ has the same time and memory complexities as Dijkstra's algorithm. However, in a graph representing a map (sparse, with uniformly-distributed nodes and random edge weights) and using as heuristic the euclidian distance between $u$ and $d$, it has a complexity of $O(\sqrt{|V|} \cdot (\text{T}_{em}+\text{T}_{dk}))$, given the A* algorithm will trace a more or less straight line to the destination, crossing $\sqrt{|V|}$ nodes which (because the graph is sparse) are adjacent to $O(\sqrt{|V|})$ edges. Because all nodes are still in $Q$, its size is still $|V|$ \footnote{We can implement $Q$ so that it only has nodes with keys different from $\infty$, but that would make no difference in terms of complexity, since we would mean there would still be up to $O(\sqrt{N})$ nodes in $Q$, and we would still have $O(\log |Q|)=O(\log \sqrt{|V|})=O(\frac{1}{2}\log |V|)=O(\log |V|)$}.
If either a binary heap or a Fibonacci heap is chosen, it makes no difference for the total time complexity, which is $O(\sqrt{|V|} \log |V|)$ in both cases.\par
Similarly to Dijkstra's algorithm, the heaps are the only large data structures we use so this algorithm's memory complexity is $O(|V|)$.\par
This means the A* algorithm is at least as fast as Dijkstra's algorithm as long as $\hat{h}$ belongs to the same asymptotic class as $O(\text{T}_{dk})$, which is $O(\log |V|)$ for both types of heaps we analysed.
\subsubsection{Remarks}
In our case, we can easily point as an heuristic $\hat{h}(u)$ the time it would take the van to go from $u$ to $d$ in a straight line at highway speed, given it gives us a lower bound on the time it would take to actually reach $d$.
\section{Strongly connected components problem}
\begin{itemize}
    \item \textbf{Summary:} Given a directed graph and a node, find the node's strongly connected component.
    \item \textbf{Input:} Graph $G=(V,E)$ and pivot $s \in V$.
    \item \textbf{Output:} $SCC$ of $s$.
\end{itemize}
\subsection{Korasaju's algorithm}
\subsection{Tarjan's algorithm}
\subsection{Divide-and-Conquer Strong Components algorithm}
The Divide-and-Conquer Strong Components (DCSC) algorithm is a mostly unknown strongly connected component algorithm, proposed in 2000 by Fleischer et al. \cite{fleischer-dcsc}. Its main ideas are the two lemmas:
\begin{lemma} \label{lem:dcsc1}
    The $SCC(p)=Desc(p) \cap Pred(p)$ where $Desc(p)$ are the descendants and $Pred(p)$ the predecessors of $p$.
\end{lemma}
\begin{proof}
    $Desc(p) \cap Pred(p) \subseteq SSC(p)$, given that a node $u \in Desc(p) \cap Pred(p)$ can reach and be reached from $p$, thus being able to trivially reach any other node $v \in Desc(p) \cap Pred(p)$ through a path passing through $p$.\par
    A node $u \in SSC(p)$ must meet both conditions, otherwise it is either false that there is a path from $p$ to $u$, or it is false that there is a path from $u$ to $p$, thus violating the definition of an SSC.
\end{proof}
\begin{lemma} \label{lem:dcsc2}
    Any SSC is a subset of the descendants of $p$, of the predecessors of $p$, or of the remaining.
\end{lemma}
We will not endeavour into proving lemma \ref{lem:dcsc2} since our implementation does not require it, adding to the fact it is proven in \cite{fleischer-dcsc}.\par
The lecture notes go on to describe how these lemmas can be implemented as a divide-and-conquer algorithm to find all SCCs, however we are more interested in a variant designed by ourselves, to obtain the SCC of node $s$ and supported only on lemma \ref{lem:dcsc1}.
\begin{center}
    \begin{algorithm}[H]
        \caption{Divide-and-Conquer Strong Components (DCSC) algorithm}
        \label{alg-dcsc}
        \begin{minipage}[t]{0.49\linewidth}
            (a) Original version
            \begin{algorithmic}[1]
                \Function{DCSC}{$G(V,E)$}
                    \State {$D \gets \Call{DFS}{G, s}$} \Comment {$Descendants$}
                    \State {$P \gets \Call{DFS}{G^T, s}$} \Comment {$Predecessors$}
                    \State {$R \gets G \backslash (D \cup P)$} \Comment {$Remainder$}
                    \State {$SCC \gets D \cap P$}
                    \State {$D' \gets \Call{DCSC}{D \backslash SSC}$}
                    \State {$P' \gets \Call{DCSC}{P \backslash SSC}$}
                    \State {$R' \gets \Call{DCSC}{R}$}
                    \State \Return {$\{SSC\} \cup D' \cup P' \cup R'$}
                \EndFunction
            \end{algorithmic}
        \end{minipage}
        \begin{minipage}[t]{0.49\linewidth}
            (b) Mathematical version
            \begin{algorithmic}[1]
                \Function{DCSCv}{$G(V,E)$, $s$}
                    \State {$D \gets \Call{DFS}{G, s}$} \Comment {$Descendants$}
                    \State {$P \gets \Call{DFS}{G^T, s}$} \Comment {$Predecessors$}
                    \State \Return {$D \cap P$}
                \EndFunction
            \end{algorithmic}
            (c) Programmatic version
            \begin{algorithmic}[1]
                \Function{DCSCv}{$Adj$, $s$}
                    \State {$D = \Call{DFS}{Adj, s}$} \Comment {$Descendants$}
                    \State {$Adj.\Call{Transpose}{ }$}
                    \State {$P = \Call{DFS}{Adj, s}$} \Comment {$Predecessors$}
                    \For {$u : V$} {$SSC[u] = D[u] \text{ AND } P[u]$}
                    \EndFor
                    \State \Return {$SSC$}
                \EndFunction
            \end{algorithmic}
        \end{minipage}
    \end{algorithm}
\end{center}
\subsubsection{Proof of correctness}
Both algorithms are trivially correct from lemmas \ref{lem:dcsc1} and \ref{lem:dcsc2}.
\subsubsection{Complexity analysis}
\chapter{Use cases}
\chapter{Conclusion}
\bibliographystyle{acm}
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{report}
\end{document}
